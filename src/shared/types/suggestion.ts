/**
 * Suggestion Domain Types
 * AI-generated move suggestions
 *
 * Defines structures for:
 * - Suggestion data
 * - Suggestion request options
 * - Suggestion scoring/ranking
 */

import type { Position } from './game'

/**
 * AI move suggestion
 * Generated by the suggestion engine to help players find valid moves
 *
 * Sorted by score (descending) where score is based on:
 * - Word length
 * - Letter rarity (from scoring.ts)
 * - Potential future moves
 */
export interface Suggestion {
  /** Position to place the letter */
  readonly position: Position

  /** Letter to place (uppercase) */
  readonly letter: string

  /** Word that will be formed */
  readonly word: string

  /** Calculated score for this move */
  readonly score: number
}

/**
 * Options for generating suggestions
 * Allows customization of the suggestion engine
 */
export interface SuggestOptions {
  /**
   * Maximum number of suggestions to generate
   * Default: 20, Max: 200
   */
  readonly limit?: number

  /**
   * Words already used in the game
   * Suggestions will exclude these words
   */
  readonly usedWords?: string[]

  /**
   * Base word to exclude from suggestions
   * Prevents suggesting the initial word
   */
  readonly baseWord?: string

  /**
   * Minimum word length for suggestions
   * Default: 3 letters
   */
  readonly minLength?: number

  /**
   * Whether to include low-scoring suggestions
   * Default: true
   */
  readonly includeLowScore?: boolean
}

/**
 * Suggestion with additional metadata
 * Used for UI display and ranking
 */
export interface RankedSuggestion extends Suggestion {
  /** Rank in the suggestion list (1-indexed) */
  readonly rank: number

  /** Quality tier (high/medium/low) */
  readonly tier: 'high' | 'medium' | 'low'

  /** Whether this is the top suggestion */
  readonly isTop: boolean
}

/**
 * Suggestion response from API
 * Includes suggestions and metadata
 */
export interface SuggestionsResponse {
  /** Array of suggestions */
  readonly suggestions: Suggestion[]

  /** Total suggestions found (before limit) */
  readonly totalFound: number

  /** Limit applied to results */
  readonly limit: number

  /** Generation time in milliseconds */
  readonly generationTimeMs?: number
}

/**
 * Compare two suggestions for sorting (descending by score)
 * @param a - First suggestion
 * @param b - Second suggestion
 * @returns Comparison result
 */
export function compareSuggestions(a: Suggestion, b: Suggestion): number {
  // Primary: score (descending)
  if (a.score !== b.score) {
    return b.score - a.score
  }

  // Secondary: word length (descending)
  if (a.word.length !== b.word.length) {
    return b.word.length - a.word.length
  }

  // Tertiary: alphabetical
  return a.word.localeCompare(b.word)
}

/**
 * Filter suggestions by minimum score
 * @param suggestions - Array of suggestions
 * @param minScore - Minimum score threshold
 * @returns Filtered suggestions
 */
export function filterByMinScore(suggestions: Suggestion[], minScore: number): Suggestion[] {
  return suggestions.filter(s => s.score >= minScore)
}

/**
 * Group suggestions by score tier
 * @param suggestions - Array of suggestions
 * @param highThreshold - Score threshold for high tier (default: 10)
 * @param mediumThreshold - Score threshold for medium tier (default: 5)
 * @returns Suggestions grouped by tier
 */
export function groupByTier(
  suggestions: Suggestion[],
  highThreshold = 10,
  mediumThreshold = 5,
): Record<'high' | 'medium' | 'low', Suggestion[]> {
  const groups = {
    high: [] as Suggestion[],
    medium: [] as Suggestion[],
    low: [] as Suggestion[],
  }

  for (const suggestion of suggestions) {
    if (suggestion.score >= highThreshold) {
      groups.high.push(suggestion)
    }
    else if (suggestion.score >= mediumThreshold) {
      groups.medium.push(suggestion)
    }
    else {
      groups.low.push(suggestion)
    }
  }

  return groups
}
